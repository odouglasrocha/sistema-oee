const mongoose = require('mongoose');

const optimizationScheduleSchema = new mongoose.Schema({
  week: {
    type: Number,
    required: true,
    min: 1,
    max: 53
  },
  year: {
    type: Number,
    required: true,
    min: 2020,
    max: 2030
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true
  },
  category: {
    type: String,
    required: true,
    enum: ['speed_optimization', 'setup_reduction', 'quality_improvement', 'maintenance', 'training', 'equipment_upgrade', 'process_improvement']
  },
  machineIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Machine'
  }],
  opportunityId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'OptimizationOpportunity'
  },
  status: {
    type: String,
    required: true,
    enum: ['planned', 'in_progress', 'completed', 'cancelled', 'postponed'],
    default: 'planned'
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },
  startDate: {
    type: Date,
    required: true
  },
  endDate: {
    type: Date,
    required: true
  },
  actualStartDate: {
    type: Date
  },
  actualEndDate: {
    type: Date
  },
  progress: {
    type: Number,
    min: 0,
    max: 100,
    default: 0
  },
  assignedTo: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }],
  responsibleUser: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  estimatedHours: {
    type: Number,
    min: 0
  },
  actualHours: {
    type: Number,
    min: 0
  },
  estimatedCost: {
    type: Number,
    min: 0
  },
  actualCost: {
    type: Number,
    min: 0
  },
  expectedResults: {
    oeeImprovement: {
      type: Number,
      min: 0,
      max: 100
    },
    availabilityImprovement: {
      type: Number,
      min: 0,
      max: 100
    },
    performanceImprovement: {
      type: Number,
      min: 0,
      max: 100
    },
    qualityImprovement: {
      type: Number,
      min: 0,
      max: 100
    },
    costSavings: {
      type: Number,
      min: 0
    }
  },
  actualResults: {
    oeeImprovement: {
      type: Number,
      min: -100,
      max: 100
    },
    availabilityImprovement: {
      type: Number,
      min: -100,
      max: 100
    },
    performanceImprovement: {
      type: Number,
      min: -100,
      max: 100
    },
    qualityImprovement: {
      type: Number,
      min: -100,
      max: 100
    },
    costSavings: {
      type: Number
    }
  },
  tasks: [{
    title: {
      type: String,
      required: true
    },
    description: String,
    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    status: {
      type: String,
      enum: ['pending', 'in_progress', 'completed', 'cancelled'],
      default: 'pending'
    },
    dueDate: Date,
    completedAt: Date,
    estimatedHours: Number,
    actualHours: Number
  }],
  milestones: [{
    title: {
      type: String,
      required: true
    },
    description: String,
    targetDate: {
      type: Date,
      required: true
    },
    completedAt: Date,
    status: {
      type: String,
      enum: ['pending', 'completed', 'missed'],
      default: 'pending'
    }
  }],
  dependencies: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'OptimizationSchedule'
  }],
  risks: [{
    description: {
      type: String,
      required: true
    },
    probability: {
      type: String,
      enum: ['low', 'medium', 'high'],
      required: true
    },
    impact: {
      type: String,
      enum: ['low', 'medium', 'high'],
      required: true
    },
    mitigation: String,
    status: {
      type: String,
      enum: ['identified', 'mitigated', 'occurred'],
      default: 'identified'
    }
  }],
  notes: {
    type: String
  },
  attachments: [{
    filename: String,
    originalName: String,
    mimetype: String,
    size: Number,
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  autoGenerated: {
    type: Boolean,
    default: false
  },
  recurring: {
    enabled: {
      type: Boolean,
      default: false
    },
    frequency: {
      type: String,
      enum: ['weekly', 'monthly', 'quarterly', 'annually']
    },
    nextOccurrence: Date
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Índices para performance
optimizationScheduleSchema.index({ week: 1, year: 1 });
optimizationScheduleSchema.index({ status: 1, priority: 1 });
optimizationScheduleSchema.index({ startDate: 1, endDate: 1 });
optimizationScheduleSchema.index({ machineIds: 1 });
optimizationScheduleSchema.index({ responsibleUser: 1 });

// Virtual para calcular duração em dias
optimizationScheduleSchema.virtual('duration').get(function() {
  if (this.startDate && this.endDate) {
    return Math.ceil((this.endDate - this.startDate) / (1000 * 60 * 60 * 24));
  }
  return null;
});

// Virtual para verificar se está atrasado
optimizationScheduleSchema.virtual('isOverdue').get(function() {
  return this.endDate && this.endDate < new Date() && this.status !== 'completed';
});

// Virtual para calcular eficiência de custo
optimizationScheduleSchema.virtual('costEfficiency').get(function() {
  if (this.estimatedCost && this.actualCost) {
    return ((this.estimatedCost - this.actualCost) / this.estimatedCost) * 100;
  }
  return null;
});

// Virtual para calcular eficiência de tempo
optimizationScheduleSchema.virtual('timeEfficiency').get(function() {
  if (this.estimatedHours && this.actualHours) {
    return ((this.estimatedHours - this.actualHours) / this.estimatedHours) * 100;
  }
  return null;
});

// Método estático para buscar por semana
optimizationScheduleSchema.statics.findByWeek = function(week, year) {
  return this.find({ week, year })
    .populate('machineIds', 'name code')
    .populate('responsibleUser', 'name email')
    .populate('assignedTo', 'name email')
    .sort({ priority: -1, startDate: 1 });
};

// Método estático para buscar cronograma ativo
optimizationScheduleSchema.statics.findActive = function() {
  return this.find({ status: { $in: ['planned', 'in_progress'] } })
    .populate('machineIds', 'name code')
    .populate('responsibleUser', 'name email')
    .sort({ startDate: 1 });
};

// Método para iniciar execução
optimizationScheduleSchema.methods.start = function() {
  this.status = 'in_progress';
  this.actualStartDate = new Date();
  return this.save();
};

// Método para completar
optimizationScheduleSchema.methods.complete = function(results) {
  this.status = 'completed';
  this.actualEndDate = new Date();
  this.progress = 100;
  if (results) {
    this.actualResults = { ...this.actualResults, ...results };
  }
  return this.save();
};

// Método para atualizar progresso
optimizationScheduleSchema.methods.updateProgress = function(progress) {
  this.progress = Math.max(0, Math.min(100, progress));
  
  if (this.progress === 100 && this.status !== 'completed') {
    return this.complete();
  }
  
  return this.save();
};

module.exports = mongoose.model('OptimizationSchedule', optimizationScheduleSchema);